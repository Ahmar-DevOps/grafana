"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prettier = tslib_1.__importStar(require("prettier"));
var useSpinner_1 = require("../utils/useSpinner");
var tests_1 = require("./plugin/tests");
var task_1 = require("./task");
var rimraf_1 = tslib_1.__importDefault(require("rimraf"));
var path_1 = require("path");
var util_1 = require("util");
var globby_1 = tslib_1.__importDefault(require("globby"));
var execa_1 = tslib_1.__importDefault(require("execa"));
var fs_1 = require("fs");
var bundle_1 = require("./plugin/bundle");
var tslint_1 = require("tslint");
var access = fs_1.promises.access, copyFile = fs_1.promises.copyFile, readFile = fs_1.promises.readFile, writeFile = fs_1.promises.writeFile;
var COPYFILE_EXCL = fs_1.constants.COPYFILE_EXCL, F_OK = fs_1.constants.F_OK;
var rimraf = util_1.promisify(rimraf_1.default);
exports.bundlePlugin = useSpinner_1.useSpinner('Compiling...', function (options) { return tslib_1.__awaiter(void 0, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, bundle_1.bundlePlugin(options)];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); });
exports.clean = useSpinner_1.useSpinner('Cleaning', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, rimraf(process.cwd() + "/dist")];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); });
var copyIfNonExistent = function (srcPath, destPath) {
    return copyFile(srcPath, destPath, COPYFILE_EXCL)
        .then(function () { return console.log("Created: " + destPath); })
        .catch(function (error) {
        if (error.code !== 'EEXIST') {
            throw error;
        }
    });
};
exports.prepare = useSpinner_1.useSpinner('Preparing', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Promise.all([
                    // Copy only if local tsconfig does not exist.  Otherwise this will work, but have odd behavior
                    copyIfNonExistent(path_1.resolve(__dirname, '../../config/tsconfig.plugin.local.json'), path_1.resolve(process.cwd(), 'tsconfig.json')),
                    // Copy only if local prettierrc does not exist.  Otherwise this will work, but have odd behavior
                    copyIfNonExistent(path_1.resolve(__dirname, '../../config/prettier.plugin.rc.js'), path_1.resolve(process.cwd(), '.prettierrc.js')),
                ])];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); });
// @ts-ignore
var typecheckPlugin = useSpinner_1.useSpinner('Typechecking', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, execa_1.default('tsc', ['--noEmit'])];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); });
var getTypescriptSources = function () { return globby_1.default(path_1.resolve(process.cwd(), 'src/**/*.+(ts|tsx)')); };
var getStylesSources = function () { return globby_1.default(path_1.resolve(process.cwd(), 'src/**/*.+(scss|css)')); };
exports.prettierCheckPlugin = useSpinner_1.useSpinner('Prettier check', function (_a) {
    var fix = _a.fix;
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var _b, prettierConfig, paths, promises, failures;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, Promise.all([
                        readFile(path_1.resolve(__dirname, '../../config/prettier.plugin.config.json'), 'utf8').then(function (contents) { return JSON.parse(contents); }),
                        Promise.all([getStylesSources(), getTypescriptSources()]).then(function (results) { return results.flat(); }),
                    ])];
                case 1:
                    _b = tslib_1.__read.apply(void 0, [_c.sent(), 2]), prettierConfig = _b[0], paths = _b[1];
                    promises = paths.map(function (path) {
                        return readFile(path, 'utf8')
                            .then(function (contents) {
                            var config = tslib_1.__assign(tslib_1.__assign({}, prettierConfig), { filepath: path });
                            if (fix && !prettier.check(contents, config)) {
                                return prettier.format(contents, config);
                            }
                            else {
                                return undefined;
                            }
                        })
                            .then(function (newContents) {
                            if (newContents === undefined) {
                                return true; // Nothing to fix
                            }
                            else if (fix) {
                                if (newContents.length > 10) {
                                    return writeFile(path, newContents)
                                        .then(function () {
                                        console.log("Fixed: " + path);
                                        return true;
                                    })
                                        .catch(function (error) {
                                        console.log("Error fixing " + path, error);
                                        return false;
                                    });
                                }
                                console.log("No automatic fix for: " + path);
                            }
                            return false;
                        })
                            .then(function (success) { return ({ path: path, success: success }); });
                    });
                    return [4 /*yield*/, Promise.all(promises)];
                case 2:
                    failures = (_c.sent()).filter(function (_a) {
                        var success = _a.success;
                        return !success;
                    });
                    if (failures.length > 0) {
                        console.log('\nFix Prettier issues in following files:');
                        failures.forEach(function (_a) {
                            var path = _a.path;
                            return console.log(path);
                        });
                        console.log('\nRun toolkit:dev to fix errors');
                        throw new Error('Prettier failed');
                    }
                    return [2 /*return*/];
            }
        });
    });
});
exports.lintPlugin = useSpinner_1.useSpinner('Linting', function (_a) {
    var fix = _a.fix;
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var tsLintConfigPath, error_1, options, configuration, sourcesToLint, lintPromises, lintResults, failures;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    tsLintConfigPath = path_1.resolve(process.cwd(), 'tslint.json');
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, access(tsLintConfigPath, F_OK)];
                case 2:
                    _b.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_1 = _b.sent();
                    tsLintConfigPath = path_1.resolve(__dirname, '../../config/tslint.plugin.json');
                    return [3 /*break*/, 4];
                case 4:
                    options = {
                        fix: fix === true,
                        formatter: 'json',
                    };
                    configuration = tslint_1.Configuration.findConfiguration(tsLintConfigPath).results;
                    return [4 /*yield*/, getTypescriptSources()];
                case 5:
                    sourcesToLint = _b.sent();
                    lintPromises = sourcesToLint.map(function (fileName) {
                        return readFile(fileName, 'utf8').then(function (contents) {
                            var linter = new tslint_1.Linter(options);
                            linter.lint(fileName, contents, configuration);
                            return linter.getResult();
                        });
                    });
                    return [4 /*yield*/, Promise.all(lintPromises)];
                case 6:
                    lintResults = (_b.sent()).filter(function (_a) {
                        var errorCount = _a.errorCount, warningCount = _a.warningCount;
                        return errorCount > 0 || warningCount > 0;
                    });
                    if (lintResults.length > 0) {
                        console.log('\n');
                        failures = lintResults.reduce(function (failures, result) {
                            return tslib_1.__spread(failures, result.failures);
                        }, []);
                        failures.forEach(function (f) {
                            // tslint:disable-next-line
                            console.log((f.getRuleSeverity() === 'warning' ? 'WARNING' : 'ERROR') + ": " + f.getFileName().split('src')[1] + "[" + (f.getStartPosition().getLineAndCharacter().line + 1) + ":" + f.getStartPosition().getLineAndCharacter().character + "]: " + f.getFailure());
                        });
                        console.log('\n');
                        throw new Error(failures.length + " linting errors found in " + lintResults.length + " files");
                    }
                    return [2 /*return*/];
            }
        });
    });
});
exports.pluginBuildRunner = function (_a) {
    var coverage = _a.coverage;
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, exports.clean()];
                case 1:
                    _b.sent();
                    return [4 /*yield*/, exports.prepare()];
                case 2:
                    _b.sent();
                    return [4 /*yield*/, exports.prettierCheckPlugin({ fix: false })];
                case 3:
                    _b.sent();
                    return [4 /*yield*/, exports.lintPlugin({ fix: false })];
                case 4:
                    _b.sent();
                    return [4 /*yield*/, tests_1.testPlugin({ updateSnapshot: false, coverage: coverage, watch: false })];
                case 5:
                    _b.sent();
                    return [4 /*yield*/, exports.bundlePlugin({ watch: false, production: true })];
                case 6:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    });
};
exports.pluginBuildTask = new task_1.Task('Build plugin', exports.pluginBuildRunner);
//# sourceMappingURL=plugin.build.js.map